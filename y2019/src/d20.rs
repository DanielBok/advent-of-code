use std::cmp::max;
use std::collections::{HashMap, HashSet, VecDeque};

const PUZZLE_INPUT: &str = "
                                         V         C   O           F   O     A   K     H
                                         Q         U   B           P   C     A   M     Y
  #######################################.#########.###.###########.###.#####.###.#####.#######################################
  #...#.....................#...........#.#...#.......#.......#.......#.#...........#.#.....#.#.......#.#...#.......#.#.#.#...#
  ###.#####.#############.#############.#.#.#.#.#########.#.###.###.###.###.###.#####.###.###.#.#######.###.#.#######.#.#.#.###
  #.#.....#.#.#.....#...........#.....#.....#.#.........#.#...#...#...#...#.#.....#.....#...#...#.........#...........#.#...#.#
  #.#####.###.###.#######.###.#####.#.###.###.###.###.#######.#.#.#######.###.#.#####.###.###.#.#####.#####.###.#######.#.###.#
  #...#.....#.#.#.....#...#.....#...#.......#...#.#.#.....#...#.#.....#.#...#.#.#.......#.....#.#...#.#.#.#...#.....#.#.......#
  #.#######.#.#.#.#############.#.#.#.#######.#####.#.#####.#######.###.#.###.#.#####.#.#.#.#######.#.#.#.#.#########.#.#####.#
  #...#.....#.....#.#.#...#.#.....#.#.#.......#.#.......#.....#.#.#.#.#...#...#.#.....#...#...#...............#.#...#.#.....#.#
  #.###.#.#######.#.#.###.#.###########.#####.#.###.#####.#.###.#.#.#.#.#.###.#.###.#.#######.###.###.#.#.#####.#.###.###.#####
  #...#.#.#...#...#.....#.......#.#.#.....#...#.....#.#.#.#...#.......#.#.#.#.#.#...#.#.....#.......#.#.#...#...#...#.......#.#
  #.#####.#.###.#####.###.###.#.#.#.#.###.###.###.###.#.#####.#.#.#.###.###.#.#######.#.#.#######.#.###.#####.###.#######.###.#
  #...#.....#.........#.....#.#.#...#.#...#.#...#.......#.....#.#.#.#.......#.#.#.......#.#.....#.#.#.#...#...........#.#...#.#
  ###.#.#####.#.###.#.#########.###.#####.#.#####.###.###.#.###.#######.#####.#.#.#######.#.#####.###.#.#########.###.#.#.###.#
  #...#.#...#.#.#.#.#.#.#.....#.#.#.#.#.....#...#...#.#...#.#...#.........#.....#.#...#.#.......#.#.#.#.#...#...#.#.#.#.#...#.#
  ###.#.#.#######.###.#.#.#####.#.#.#.#.###.#.###.###.#.###.###.#######.#####.#####.###.###.#####.#.#.###.#.###.###.#.#.#.###.#
  #...#.....#.#.#.#.......#.#.......#...#.......#.#...#...#.#...#.#.....#...#.....#.............#.......#.#.#.#.#...#...#.#...#
  ###.###.###.#.#.###.#.#.#.#####.#.###.#.#.###.#.###.#.###.###.#.#####.###.#.#######.###########.#######.###.#.#.#.#.###.#.###
  #.#.......#.#.......#.#.....#...#...#.#.#...#.#.#...#.#.#.#...#...#...#.#...#.#.#...........#.#...#...#...#...#.#...#...#...#
  #.###.#####.#.#######.#.#.#####.###.#.#############.#.#.#####.###.###.#.###.#.#.#####.###.#.#.###.#.###.###.#######.###.#.###
  #.#.........#.#.#.....#.#...#.#.#.#.......#...#...#.#.#.#.#.........#.#.#.#.#.#.#.....#...#.#...#.#...#...#.#.#...#.#.#.....#
  #.###.###.#####.#####.###.###.###.###.#######.###.#.#.#.#.#########.#.#.#.#.#.#.#.###.#######.#####.###.###.#.#.#.#.#.#.#.#.#
  #.......#.#.#.#.#...#...#.....#...........#.....#...#...#...........#...#.#.....#.#...........#.#.#.#...#...#.#.#.....#.#.#.#
  #####.#####.#.#.###.#######.#########.#####.#.###.#####.#####.#######.###.#####.###.#######.###.#.#.###.#.#.#.###.#####.###.#
  #.....#.....#.#.#.#.....#.............#...#.#.#.#...#...#.#.........#.....#.....#.......#.#.#.#.......#.#.#.#...#.#...#.#.#.#
  #####.###.###.#.#.###.#######.#######.###.###.#.###.#.###.###.###.#######.#.#######.#####.#.#.#.###.###.###.#.#.#.###.###.#.#
  #...#.#.......#.#.#.............#.#...#...#.......#.#...#.#.#.#.#...#.....#.......#.....#.........#.#.......#.#.#.....#.....#
  #.###.#####.###.#.#.#.###.#######.###.#.#.###.#.###.###.#.#.#.#.###.#.#####.#####.#.###.#.###.#.#####.#.#######.#.#########.#
  #.#.#...#.#.....#.#.#...#.#.#.#.....#.#.#.#.#.#.......#.....#.#.....#.#.....#...#.#...#.#.#...#...#...#...#...#.#.#.#.#.....#
  #.#.#.###.#.#####.#.#######.#.###.###.#.#.#.#.#####.#.#.#.#####.#.###.###.#.#.#.#.###.#################.#.###.#.#.#.#.#.#.#.#
  #...#.....#.......#.#...#...............#...#...#...#.#.#...#.#.#...#...#.#.#.#...#.......#...#.#.#...#.#...#.........#.#.#.#
  ###.#.#####.###########.#########.#.#######.###.#########.###.#####.###.#####.###.#.#.#.###.###.#.#.###.#########.#########.#
  #.....#.......#.#...#...#...#.#...#.#.......#.....#.........#.........#...#.....#.#.#.#.....#...#...#.......#.......#.......#
  #.#####.#######.###.#.###.###.#######.#########.###########.###.#########.#####.###.###########.#.#####.#########.#########.#
  #.#.#...#...#...#.#.#...#.......#    Y         K           Q   T         C     C   V        #.#...#.#...#.#.#...#...#...#...#
  #.#.###.#.###.###.#.#.#######.###    G         F           J   M         U     O   Q        #.###.#.###.#.#.#.#####.#.#####.#
  #.....#...#.#.#.....#.#.....#.#.#                                                           #.#.#.....#.....................#
  ###.###.###.#.#.#.###.###.#.#.#.#                                                           #.#.#.#.###.###.#.###.#.#.###.###
  #...#.......#.#.#.......#.#......HY                                                         #...#.#.#.....#.#.#...#.#.#.....#
  #.#.#.###.###.#######.#######.###                                                           #.###.#.###.#######.#.#.###.#.###
TM..#...#.......#.#.......#.#.....#                                                         FP..#...#.#.......#.#.#.#.#...#...#
  #.#.#.#####.#.#.#####.###.#####.#                                                           #.#.###.#.###.#.#.###.###.#####.#
  #.#.#...#...#.#.....#.#.#.....#.#                                                           #.....#...#.#.#.#...#.#.#.#...#..PI
  #####.###.#####.#####.#.###.#.#.#                                                           ###########.#####.#####.#####.###
  #.#.#.#.....................#...#                                                           #.................#.........#....ML
  #.#.###########.###.###.###.#.###                                                           ###.#######.#.#.###.#.#######.#.#
CO........#.........#...#.#.#.#.#.#                                                           #.....#.#...#.#.....#...#.....#.#
  #####.#########.#######.#.#####.#                                                           #####.#####.#.#########.#.#.#.#.#
  #.........#.........#...#.......#                                                         MV....#.....#.#.....#.....#.#.#.#.#
  #.#####.#.###############.#######                                                           #.#.###.###.#.#.###.#####.#####.#
  #...#.#.#.#.#...#...#.......#...#                                                         OB..#.......#.#.#.#.#.........#.#..UO
  ###.#######.#.#####.#####.###.#.#                                                           #################.#######.###.#.#
  #.............................#..MX                                                         #.........#.........#.#.#...#...#
  #########.###.###.#.#############                                                           #.#####.#########.#.#.#.#########
SV....#.#.#...#.#...#.#.#...#...#.#                                                         VA..#.......#.......#.........#.#.#
  ###.#.#.#############.#.#.#.#.#.#                                                           ###.#############.###.#######.#.#
  #.....#...#.....#...#...#...#...#                                                           #.......#.#.#...#...#...#...#....CQ
  #####.#.###.###.###.###.#######.#                                                           #######.#.#.#.#####.###.###.###.#
  #...#.......#.#.#.#.#.........#..KT                                                         #...#.................#.........#
  #.###.#.#.###.###.#.#.#.#####.#.#                                                           #.#####################.#####.###
  #...#.#.#.............#...#...#.#                                                           #...#.#...............#.#.#.#.#.#
  #.#########.#.###.###.#.#########                                                           #.###.#.#######.#####.###.#.###.#
  #.....#.#...#.#.....#.#...#.#.#.#                                                         XE......#.#...#...#.#...#.......#.#
  #.#.###.###.###############.#.#.#                                                           #####.#.#########.#.###.#####.#.#
KF..#.#.....#.#.........#...#.#...#                                                           #.....#.......#.#.......#.....#..QJ
  ###.###.#######.#######.###.###.#                                                           #.#######.#####.#.#######.#####.#
  #...#...#.#.#.#.....#.....#.#.#..PA                                                         #.........#.....#.#.....#.......#
  ###.#.#.#.#.#.#.#####.#.###.#.#.#                                                           ###########.#########.#########.#
  #.#...#...............#.........#                                                           #.#.....#.....#.....#...#.....#.#
  #.#.#########.#########.#.###.###                                                           #.#.#.#.#.###.#.#.###.#.###.#.###
  #.#...#.....#.#.#.#.....#...#...#                                                           #...#.#.....#...#.....#.....#...#
  #.#####.#.#.###.#.###############                                                           #.#######.#.###.###.###.#######.#
  #...#.#.#.#.....#.......#...#.#.#                                                         ML....#.#...#.#.#...#.#.#.#...#....MX
  #.###.#.#####.###.#######.#.#.#.#                                                           #####.#######.#######.#####.#####
  #.....#.#.#...#.....#.....#......KM                                                         #.#.............#.#.............#
  #.#.###.#.#.###.###.#.#######.###                                                           #.#.###.#####.#.#.#.#######.###.#
KV..#.....#.......#.....#.#...#...#                                                         CT..#.#.#...#.#.#.........#...#...#
  #######################.#.#######                                                           #.#.###.###.###.#############.###
  #.#.#.....#.#...................#                                                           #.#...#...#...#.#.....#.......#..FW
  #.#.#.#.###.###.#####.#.#.#.#.###                                                           #.###.#####.#######.#######.###.#
YG..#...#.....#...#.#.#.#.#.#.#.#..OC                                                         #.......#.#.......#.#...#.#.....#
  #.#.#######.#.###.#.#######.#.#.#                                                           #########.#####.###.###.#.#######
  #.#.....#...#...........#...#...#                                                         FW................#...............#
  #.###.###.#####.#########.#.###.#                                                           #.#.###.###.###.###.#.#.#.#.#.###
ZZ......#.............#.....#.#.#.#                                                           #.#.#...#...#.......#.#.#.#.#....KT
  #.###.###.#####.#.#.#######.#.###            K   O       U           S       P       C      #.#.###.###.#######.###.#####.#.#
  #.#.#.#.#.....#.#.#.....#.#.....#            V   E       O           V       I       Q      #.#.#...#.#.#...#.#...#...#...#.#
  #.#.###.#.#.#.#.#.#######.#.###.#############.###.#######.###########.#######.#######.#############.#.#####.#.#.#.#.###.#.#.#
  #...#.....#.#.#.#.....#.......#.#.....#.......#.......#.#.....#.#.....#.#.......#.#.....#...#.#.........#.......#.#.#...#.#.#
  #.#.#.#.#.#########.#######.#######.#########.#.#.#.###.#####.#.###.#.#.###.#####.#.#####.#.#.#####.#######.###.#########.#.#
  #.#.#.#.#...#.#...#...#.#.#.#.#.....#.....#...#.#.#.#.#.#.........#.#.#...#...#.#.........#...#...#.....#.#.#.........#...#.#
  #.###.#.#####.#.###.###.#.#.#.#####.#####.###.#.#####.#.###.#.#######.#.###.###.###.#####.###.###.#.#####.#.#####.#.#.#.#.###
  #.#...#...........#.#...........#.....#...#...#...#.#.#.....#.#...#.#.#...#...#...#...#.#...#.#.....#.#.........#.#.#.#.#...#
  #####.###.###.###.###.###.#.#.#####.#####.#.###.###.#.#####.###.#.###.#.#.###.###.#.###.#########.#.#.#####.#####.#.###.###.#
  #.....#.#.#.....#...#.#...#.#.#...............#.......#.#.....#.#...#.#.#...#...#.......#.#.......#...#...#.#.#.#.#...#.#.#.#
  #.###.#.#####.#.#.#####.#.#.#######.#######.#####.###.#.#.###.#.###.#.#.###.#.#####.#.#.#.#######.#######.#.#.#.#######.#.#.#
  #...#...#.....#.#.#.....#.#...#...#.#.#.........#.#.....#.#.#.#.#.....#...#.....#...#.#.....#.#.#.#.........#.#...#.......#.#
  #.#####.#####.###.#.#.#.#######.###.#.#.#.###.#####.###.###.#.#.#########.###.#.#####.###.###.#.###.###.###.#.#.#######.#.#.#
  #.#.....#.#.....#.#.#.#.#...#.......#...#...#.#...#...#.#.#.#.#.......#.....#.#.#.....#.#.#.#.#.....#.....#.........#.#.#.#.#
  #.#.#.#.#.###.#.#########.#########.#.#######.#.#.###.###.#.#.#.#.###.#.#########.###.#.###.#.#####.#.#######.#.#.###.#####.#
  #.#.#.#...#...#...#.#.#.#.#.#.......#.#.#.#...#.#.......#.....#.#.#.#.#...#.....#.#.....#.#.#.#.#...#.#.......#.#.#.#.#...#.#
  #.#####.#.#.#.#####.#.#.#.#.###########.#.###.#.###.#######.#.#.#.#.#.#.#######.#####.###.#.#.#.#####.###.#.#.#####.#.#.#####
  #.....#.#.#.#.#.#.#.#.........#...#...#.#.....#...#.#.......#.#.#.#...#...#.#.......#.............#.....#.#.#...........#.#.#
  #.#####.###.#.#.#.#.#####.#.#####.###.#.###.#.#.#####.#.###.###.#.#.###.#.#.#.###.###.#######.#####.###########.#.###.###.#.#
  #.#.....#.#.#.#.........#.#.#...#...#.....#.#.#.....#.#.#.#...#.#.#...#.#.#.#.#...#.....#.#.#.#...#...#.........#...#.......#
  #.#####.#.#.#####.#.#######.#.#####.###.#.#.###.#.#####.#.#.#.###.###.#.###.###.#.#.#####.#.#####.#########.#.###.###.#.###.#
  #.#.......#.#.#.#.#.#.#...#.#.....#...#.#.#...#.#.#.....#...#.#...#...#.#.....#.#.#.....#.....#.........#...#...#.#.#.#...#.#
  #######.#####.#.###.#.###.#.#.#####.###.#####.#.#########.###.#####.###.#.#.###.#.###.###.#.###.#############.#####.#.#####.#
  #.#.#...#.#.........#...........#.#.#...#.#...#.#.#...#...#.#...#.....#.#.#...#.#.........#.#.#.#.#...#...#.......#.....#.#.#
  #.#.#.#.#.#########.#.#.###.#####.#.###.#.###.#.#.#.###.###.#######.###.#.###.#.#######.#####.#.#.#.#####.#.#.#####.#.###.#.#
  #...#.#...#...#.......#.#.................#.#.#...#.....#.#.#.#...#...#.#...#.#.#.....#.#.#.....#.........#.#.....#.#.#.....#
  #.#.#.#.###.#######.#.#.#.#.#.###.###.#.#.#.#.#.###.#.#.#.#.#.###.#.#.#.###.#.#.###.#.#.#.#####.#.#.#####.###.###.#####.#.#.#
  #.#...#.#...#.......#.#.#.#.#.#.....#.#.#.#.#.#...#.#.#.......#.#.#.#.#.....#.#...#.#.#.#.........#...#.#.#.#...#...#.#.#.#.#
  #####.###.###.#####.#.#######.###.#####.#.###.#.#########.#.###.#.###.#######.#.#.#.#.###.#.#.###.#.###.###.#.###.###.###.#.#
  #.........#.#.#.....#.#.........#.#.....#...#.#...#...#...#.#.#...#.#...#.....#.#.#.#.#...#.#.#.#.#.........#.#.........#.#.#
  #.###.#####.#####.#.###.###############.###.#.###.###.#.#####.#.#.#.#.#####.#####.#.#.#.#.#####.#.###.#####.###.###.#######.#
  #.#.....#.........#.#...#.................#...#.......#.......#.#...#.#.........#...#.#.#.......#...#.#...#.#.#...#...#...#.#
  #.#.#.#####.#.###.###.#.###.###.#.#.#.###.#####.###.###.#.#######.###.#######.#######.#.#.#######.#####.#####.#####.#.#.###.#
  #.#.#.....#.#.#...#...#.#...#...#.#.#.#.......#...#.#...#.....#.........#.....#.........#.....#...................#.#.#.....#
  #############################################.###.###########.#####.#####.#######.###########################################
                                               X   V           C     O     M       P
                                               E   A           T     E     V       A                                             ";

pub fn solve_a() {
    let map = form_map(PUZZLE_INPUT);
    let ans = bfs(&map);

    println!("Solution A: {}", ans.unwrap());
}

fn bfs(map: &HashMap<Point, Tile>) -> Option<usize> {
    let start = *map.iter().find(|&(_, t)| *t == Tile::Start).unwrap().0;
    let mut queue: VecDeque<(Point, usize)> = VecDeque::from([(start, 0)]);
    let mut distances: HashMap<Point, usize> = HashMap::from([(start, 0)]);

    while let Some((curr, n_steps)) = queue.pop_front() {
        if let Some(dist) = distances.get_mut(&curr) {
            if n_steps > *dist {
                continue;
            } else {
                *dist = n_steps;
            }
        } else {
            distances.insert(curr, n_steps);
        }

        for nbr in curr.neighbours() {
            if let Some(tile) = map.get(&nbr) {
                match tile {
                    Tile::Floor => {
                        queue.push_back((nbr, n_steps + 1));
                    }
                    Tile::Portal { loc: next_pt, code: _, is_edge: _ } => {
                        // moving to that tile and then teleporting takes 2 steps
                        queue.push_back((*next_pt, n_steps + 2))
                    }
                    Tile::Wall | Tile::Start => { continue; }
                    Tile::End => {
                        return Some(n_steps + 1);
                    }
                }
            }
        }
    };

    None
}

#[derive(Debug, PartialEq, Eq, Clone)]
enum Tile {
    Floor,
    Wall,
    Portal { code: String, loc: Point, is_edge: bool },
    Start,
    End,
}


#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]
struct Point(usize, usize);

impl Point {
    // should only be called on floor tiles, so there's no risk of saturating moves
    fn neighbours(&self) -> [Point; 4] {
        [
            Point(self.0 - 1, self.1),
            Point(self.0 + 1, self.1),
            Point(self.0, self.1 - 1),
            Point(self.0, self.1 + 1),
        ]
    }
}


fn input_to_grid(input: &str) -> Vec<Vec<char>> {
    input.lines()
        .skip(1)
        .map(|line| line.chars().collect::<Vec<char>>())
        .collect::<Vec<_>>()
}

fn form_map(input: &str) -> HashMap<Point, Tile> {
    let grid = input_to_grid(input);
    let n_rows = grid.len();
    let n_cols = grid.iter().fold(0, |acc, r| max(r.len(), acc));

    let mut tiles = HashMap::new();
    let mut portals = HashMap::new();

    let mut seen = HashSet::new();

    let mut queue = (0..grid.len())
        .fold(VecDeque::new(), |mut acc, i| {
            let row = (0..grid[i].len()).map(|x| Point(x, i)).collect::<Vec<_>>();
            acc.extend(row);
            acc
        });


    // bfs to form all the tile maps
    while let Some(pt) = queue.pop_front() {
        if seen.contains(&pt) {
            continue;
        }

        seen.insert(pt);
        match grid[pt.1][pt.0] {
            '#' => {
                tiles.insert(pt, Tile::Wall);
            }
            '.' => {
                if let Some((portal_code, next_pt)) = get_portal_code(&grid, pt) {
                    if portal_code == "AA" {
                        tiles.insert(pt, Tile::Start);
                    } else if portal_code == "ZZ" {
                        tiles.insert(pt, Tile::End);
                    } else {
                        let Point(x, y) = next_pt;
                        let is_edge = x < 2 || y < 2 || x > n_cols - 3 || y > n_rows - 3;

                        if let Some(&(target_loc, target_is_edge)) = portals.get(&portal_code) {
                            // we have all the info we need to form portals. One tile for each direction
                            tiles.insert(pt, Tile::Portal { code: portal_code.clone(), loc: target_loc, is_edge });
                            tiles.insert(target_loc, Tile::Portal { code: portal_code.clone(), loc: pt, is_edge: target_is_edge });
                        } else {
                            portals.insert(portal_code, (pt, is_edge));
                        }
                    }
                } else {
                    tiles.insert(pt, Tile::Floor);
                }
            }
            _ => {
                // skip blank spaces and portal code
            }
        }
    };


    tiles
}

fn get_portal_code(grid: &Vec<Vec<char>>, pt: Point) -> Option<(String, Point)> {
    for nbr in pt.neighbours() {
        let x = nbr.0;
        let y = nbr.1;

        let c1 = grid[y][x];
        if c1.is_ascii_uppercase() {
            let code = if pt.0 == nbr.0 {
                if y < pt.1 {
                    format!("{}{}", grid[y - 1][x], c1)
                } else {
                    format!("{}{}", c1, grid[y + 1][x])
                }
            } else {
                if x < pt.0 {
                    format!("{}{}", grid[y][x - 1], c1)
                } else {
                    format!("{}{}", c1, grid[y][x + 1])
                }
            };

            assert!(code.chars().all(|x| x.is_ascii_uppercase()), "Invalid code '{}' at pt={:?} nbr={:?}", code, pt, nbr);
            return Some((code, nbr));
        }
    }
    None
}

pub fn solve_b() {
    let map = form_map(PUZZLE_INPUT);
    let ans = bfs_with_levels(&map).unwrap();

    println!("Solution B: {}", ans);
}

#[derive(PartialEq, Eq, Hash, Clone)]
struct SearchState {
    loc: Point,
    level: usize,
}

fn bfs_with_levels(map: &HashMap<Point, Tile>) -> Option<usize> {
    let start = *map.iter().find(|&(_, t)| *t == Tile::Start).unwrap().0;

    let initial_state = SearchState {
        loc: start,
        level: 0,
    };

    let mut queue = VecDeque::from([(initial_state.clone(), 0, Point(usize::MAX, usize::MAX))]);
    let mut distances: HashMap<SearchState, usize> = HashMap::from([(initial_state.clone(), 0)]);

    while let Some((state, n_steps, last_pt)) = queue.pop_front() {
        if let Some(dist) = distances.get_mut(&state) {
            if n_steps > *dist {
                continue;
            } else {
                *dist = n_steps;
            }
        } else {
            distances.insert(state.clone(), n_steps);
        }

        let SearchState { loc, level } = state;

        for nbr in loc.neighbours() {
            if nbr == last_pt {
                continue;
            }

            if let Some(tile) = map.get(&nbr) {
                match tile {
                    Tile::End if level == 0 => {
                        // ending condition
                        return Some(n_steps + 1);
                    }
                    Tile::Floor => {
                        queue.push_back((SearchState {
                            loc: nbr,
                            level,
                        }, n_steps + 1, loc));
                    }
                    Tile::Portal { code: _, is_edge, loc: next_pt } => {
                        if level == 0 && *is_edge {
                            continue;
                        }

                        // go down when at inner box, go up when at outer edges
                        let next_level = if *is_edge { level - 1 } else { level + 1 };

                        // moving to that tile and then teleporting takes 2 steps
                        queue.push_back((SearchState {
                            loc: *next_pt,
                            level: next_level,
                        }, n_steps + 2, loc));
                    }
                    _ => { continue; }
                }
            }
        }
    };

    None
}


#[cfg(test)]
mod tests {
    use std::cmp::max;

    #[test]
    fn test_get_portal_code() {
        use super::{get_portal_code, input_to_grid, Point};

        for (input, pt, exp) in [
            ("
    A
    B
  ##.##
  #####
         ", Point(4, 2), "AB"),
            ("


  ##
AB.#
  ##", Point(2, 3), "AB"),
            ("


  #####
  ##.##
    A
    B  ", Point(4, 3), "AB"),
            ("


  ###
  ##.AB
  ###

       ", Point(4, 3), "AB"),
        ] {
            let grid = input_to_grid(input);
            if let Some((code, _)) = get_portal_code(&grid, pt) {
                assert_eq!(code, String::from(exp));
            } else {
                panic!("Did not parse map correctly")
            }
        }

        let common_inp = "
         A
         A
  #######.#########
  #######.........#
  #######.#######.#
  #######.#######.#
  #######.#######.#
  #####  B    ###.#
BC...##  C    ###.#
  ##.##       ###..CJ
  ##...DE  F  ###.#
  #####    G  ###.#
  #########.#####.#
DE..#######...###.#
  #.#########.###.#
FG..#########.....#
  ###########.#.###
             Z B
             Z A    ";

        let grid = input_to_grid(common_inp);
        let n_rows = grid.len();
        let n_cols = grid.iter().fold(0, |acc, r| max(r.len(), acc));

        for (pt, exp_code, exp_is_edge) in [
            (Point(9, 6), "BC", false),
            (Point(2, 8), "BC", true),
            (Point(6, 10), "DE", false),
            (Point(2, 13), "DE", true),
            (Point(2, 15), "FG", true),
            (Point(11, 12), "FG", false),
            (Point(18, 9), "CJ", true),
            (Point(15, 16), "BA", true),
        ] {
            if let Some((code, Point(x, y))) = get_portal_code(&grid, pt) {
                assert_eq!(code, exp_code, "code does not match. Got: '{}'. Expected: {}", code, exp_code);

                let is_edge = x < 2 || y < 2 || x > n_cols - 3 || y > n_rows - 3;
                assert_eq!(is_edge, exp_is_edge, "Edge for code '{}' does not match. Got {}. Expected {}. x={} y={}. n_cols={} n_rows={}", code, is_edge, exp_is_edge, x, y, n_cols - 2, n_rows - 2);
            } else {
                panic!("B: Could not parse map correctly")
            }
        }
    }

    #[test]
    fn test_first() {
        use super::{bfs, form_map};
        for (inp, exp) in [
            ("
         A
         A
  #######.#########
  #######.........#
  #######.#######.#
  #######.#######.#
  #######.#######.#
  #####  B    ###.#
BC...##  C    ###.#
  ##.##       ###.#
  ##...DE  F  ###.#
  #####    G  ###.#
  #########.#####.#
DE..#######...###.#
  #.#########.###.#
FG..#########.....#
  ###########.#####
             Z
             Z      ", 23),
            ("
                   A
                   A
  #################.#############
  #.#...#...................#.#.#
  #.#.#.###.###.###.#########.#.#
  #.#.#.......#...#.....#.#.#...#
  #.#########.###.#####.#.#.###.#
  #.............#.#.....#.......#
  ###.###########.###.#####.#.#.#
  #.....#        A   C    #.#.#.#
  #######        S   P    #####.#
  #.#...#                 #......VT
  #.#.#.#                 #.#####
  #...#.#               YN....#.#
  #.###.#                 #####.#
DI....#.#                 #.....#
  #####.#                 #.###.#
ZZ......#               QG....#..AS
  ###.###                 #######
JO..#.#.#                 #.....#
  #.#.#.#                 ###.#.#
  #...#..DI             BU....#..LF
  #####.#                 #.#####
YN......#               VT..#....QG
  #.###.#                 #.###.#
  #.#...#                 #.....#
  ###.###    J L     J    #.#.###
  #.....#    O F     P    #.#...#
  #.###.#####.#.#####.#####.###.#
  #...#.#.#...#.....#.....#.#...#
  #.#####.###.###.#.#.#########.#
  #...#.#.....#...#.#.#.#.....#.#
  #.###.#####.###.###.#.#.#######
  #.#.........#...#.............#
  #########.###.###.#############
           B   J   C
           U   P   P               ", 58)
        ] {
            let map = form_map(inp);
            let ans = bfs(&map);
            assert!(ans.is_some_and(|x| x == exp));
        }
    }

    #[test]
    fn test_second() {
        use super::{bfs_with_levels, form_map};

        for (inp, exp) in [
            ("
         A
         A
  #######.#########
  #######.........#
  #######.#######.#
  #######.#######.#
  #######.#######.#
  #####  B    ###.#
BC...##  C    ###.#
  ##.##       ###.#
  ##...DE  F  ###.#
  #####    G  ###.#
  #########.#####.#
DE..#######...###.#
  #.#########.###.#
FG..#########.....#
  ###########.#####
             Z
             Z       ", 26),
            ("
             Z L X W       C
             Z P Q B       K
  ###########.#.#.#.#######.###############
  #...#.......#.#.......#.#.......#.#.#...#
  ###.#.#.#.#.#.#.#.###.#.#.#######.#.#.###
  #.#...#.#.#...#.#.#...#...#...#.#.......#
  #.###.#######.###.###.#.###.###.#.#######
  #...#.......#.#...#...#.............#...#
  #.#########.#######.#.#######.#######.###
  #...#.#    F       R I       Z    #.#.#.#
  #.###.#    D       E C       H    #.#.#.#
  #.#...#                           #...#.#
  #.###.#                           #.###.#
  #.#....OA                       WB..#.#..ZH
  #.###.#                           #.#.#.#
CJ......#                           #.....#
  #######                           #######
  #.#....CK                         #......IC
  #.###.#                           #.###.#
  #.....#                           #...#.#
  ###.###                           #.#.#.#
XF....#.#                         RF..#.#.#
  #####.#                           #######
  #......CJ                       NM..#...#
  ###.#.#                           #.###.#
RE....#.#                           #......RF
  ###.###        X   X       L      #.#.#.#
  #.....#        F   Q       P      #.#.#.#
  ###.###########.###.#######.#########.###
  #.....#...#.....#.......#...#.....#.#...#
  #####.#.###.#######.#######.###.###.#.#.#
  #.......#.......#.#.#.#.#...#...#...#.#.#
  #####.###.#####.#.#.#.#.###.###.#.###.###
  #.......#.....#.#...#...............#...#
  #############.#.#.###.###################
               A O F   N
               A A D   M                     ", 396)
        ] {
            let map = form_map(inp);
            let ans = bfs_with_levels(&map);

            assert!(ans.is_some_and(|x| x == exp));
        }
    }
}